---
title             : "Keeping an Eye on Hidden Markov Models in Gaze Data Classification"
shorttitle        : "HMMs in Gaze Classification"

author: 
  - name          : "Malte Valentin Lueken"
    affiliation   : "1"
    address       : "Speelmanstraat 7-3 1063ZC Amsterdam"
    email         : "malte.luken@student.uva.nl"

affiliation:
  - id            : "1"
    institution   : "University of Amsterdam"

authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  One or two sentences providing a **basic introduction** to the field,  comprehensible to a scientist in any discipline.
  
  Two to three sentences of **more detailed background**, comprehensible  to scientists in related disciplines.
  
  One sentence clearly stating the **general problem** being addressed by  this particular study.
  
  One sentence summarizing the main result (with the words "**here we show**" or their equivalent).
  
  Two or three sentences explaining what the **main result** reveals in direct comparison to what was thought to be the case previously, or how the  main result adds to previous knowledge.
  
  One or two sentences to put the results into a more **general context**.
  
  Two or three sentences to provide a **broader perspective**, readily comprehensible to a scientist in any discipline.
  
  <!-- https://tinyurl.com/ybremelq -->
  
keywords          : "keywords"
wordcount         : "X"

bibliography      : "report.bib"

floatsintext      : no
figurelist        : yes
tablelist         : yes
footnotelist      : no
linenumbers       : no
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, results = "asis")

dir <- "~/Uni/Psychologie Master/Internship/GazeHMM"

library(papaja)
library(tidyverse)
library(signal)
library(flexcircmix)
library(CircStats)
library(depmixS4)
library(psych)
library(here)
source(here("algorithm/preprocessing_helper_functions.R"))
source(here("algorithm/model_helper_functions.R"))

```

```{r set graphics theme, include=FALSE}

theme_set(theme_apa())

```


```{r load data, include=FALSE}

load(here("validation/Andersson2017_raw.Rdata"))

res <- c(1024, 768)
dim <- c(380, 300)
dist <- 670
fr <- 500

```

# Algorithm Development
As part of answering my research questions, I developed an algorithm named gazeHMM to classify gaze data into discrete eye movement events. The following section describes the development of gazeHMM and its final version that has been used to obtain results. Technical details can be found in the Technical Appendix.

## Eye Movement Metrics
Many different metrics can be used to describe gaze data and eye movement events [@Zemblys2018]. Here, the goal is to find those metrics that separate the gaze data samples belonging to different events the best. However, many metrics rely on thresholds or window ranges that have to be set by the user [e.g., the distance between the mean position in a 100 ms window before and after each sample, see @Olsson2007, and @Zemblys2018]. This can be problematic because these parameters are often set without theoretical justification and they differ substantially between metrics. Belonging to the most basic metrics, which do not require parameter settings, I used velocity, acceleration, and sample-to-sample angle [similar to relative or change in angle; @Larsson2013] in gazeHMM.  
Theoretically, these three metrics should separate eye movement events clearly. Fixations typically inherit samples with low velocity and acceleration [@Larsson2013]. Due to tremor, the angle between samples should not follow any direction but a random walk [@Duchowski2017]. In contrast, saccade samples usually have a high velocity and acceleration and follow the same direction. PSO samples tend to have moderate velocity and high acceleration since they occur after high velocity saccades [@Larsson2013]. They are specifically distinguished by their change in direction clustered around 180° [@Pekkanen2017]. Lastly, smooth pursuit samples have a moderate velocity but low acceleration (due to the smoothness) and like saccades they follow the same direction [@Larsson2013; @Leigh2015].

## Fitering and Smoothing
As with metrics, many methods can be used to filter or smooth gaze data before, while, or after computing eye movement metrics. Their purpose is to remove noise or artifacts from the gaze data that could distort the classification [@Duchowski2017]. Filtering (smoothing) methods that are applied before computing the eye movement metrics target the recorded gaze position. While removing noise, filters might also erase differences in the metrics between samples. For instance, tremor movements during fixations could be filtered out and in consequence, the samples would follow the same direction. This could complicate separating fixations from smooth pursuits. The same problem applies to PSOs and saccades where filtering could erase oscillations (see Figure \@ref(fig:filter-angle)).  

(ref:filter-angle) Example data from @Andersson2017 displayed as sample-to-sample angle (in rad) over time (in s). Line colors indicate whether the positional data has been filtered before computing the sample-to-sample angle (red) or not (blue). For this example, I used a Butterworth filter of order three and a normalized cutoff frequency of 0.3. The full line segment marks where potential oscillations are filtered out. The dashed line segment illustrates where potentially random change in angle is filtered out.

```{r, filter-angle, fig.cap="(ref:filter-angle)"}

filter.ex <- A2017$video[[3]] %>%
  mutate(x = px2va(x, dim[1], res[1], dist),
         y = px2va(y, dim[2], res[2], dist),
         angle = calc_theta(x, y),
         x.filt = as.numeric(signal::filter(signal::butter(3, 0.3), x)),
         y.filt = as.numeric(signal::filter(signal::butter(3, 0.3), y)),
         angle.filt = calc_theta(x.filt, y.filt),
         t = (t-t[1])/1e6) %>%
  dplyr::filter(t > 0.5, t < 0.75)

ggplot(filter.ex) + 
  geom_path(aes(x = t, y = force_neg_pi_pi(angle)), color = "blue") +
  geom_path(aes(x = t, y = force_neg_pi_pi(angle.filt)), color = "red") +
  annotate(geom = "segment", x = 0.525, xend = 0.54, y = -3, yend = -3, color = "black", size = 0.8) +
  annotate(geom = "segment", x = 0.635, xend = 0.67, y = -3, yend = -3, color = "black", size = 0.8, linetype = 6) +
  scale_y_circular(name = "Sample-to-sample angle (in rad)", units = "radians", limits = c(-pi, pi)) +
  scale_x_continuous(name = "Time (in s)")

```

Instead of filtering before computing the metrics, I decided to combine both in one step. Previous algorithms have used two methods that both filter and compute derivatives of the gaze position (i.e., velocity and acceleration). @Houpt2018 compute the first and second discrete derivative (similar to a Sobel and Laplace filter, respectively) of the gaze position to be used by their algorithm. Similarly, @Nystrom2010 use a Savitzky-Golay (SG) filter @Savitzky1964 to estimate velocity and acceleration from a gaze signal. Figure \@ref(fig:filter-comparison) displays velocity and acceleration signals obtained by both methods. They follow a similar trend, but the SG velocity signal is less noisy and the acceleration signal is consequently lower than the Laplace acceleration signal. Therefore, I chose to implement the SG filter to compute velocity and acceleration signals, because it filters out more noise than the discrete derivatives but still preserves the edges in the signal to distinguish between events. To preserve motor noise in the sample-to-sample angle signal, gazeHMM computes the absolute angle with the backward difference and the first discrete derivative as the forward difference (see Technical Appendix).

(ref:filter-comparison) Example data from @Andersson2017 displayed as velocity (deg/s) and acceleration (in deg/s$^2$) over time (in s). Line colors indicate which filter has been used to derive the signal. Savitzky-Golay filters were applied with order three and length five (corresponding to 10 ms).

```{r, filter-comparison, fig.cap="(ref:filter-comparison)"}

filter.comp <- A2017$video[[3]] %>%
  mutate(x = px2va(x, dim[1], res[1], dist),
         y = px2va(y, dim[2], res[2], dist),
         vel.x.sg = signal::sgolayfilt(x, m = 1),
         vel.y.sg = signal::sgolayfilt(y, m = 1),
         vel.sg = sqrt(vel.x.sg^2 + vel.y.sg^2)*fr,
         acc.x.sg = signal::sgolayfilt(x, m = 2),
         acc.y.sg = signal::sgolayfilt(y, m = 2),
         acc.sg = sqrt(acc.x.sg^2 + acc.y.sg^2)*fr^2,
         vel.x.sb = lead(x) - lag(x),
         vel.y.sb = lead(y) - lag(y),
         vel.sb = sqrt(vel.x.sb^2 + vel.y.sb^2)*fr,
         acc.x.lp = lead(x) - 2*x + lag(x),
         acc.y.lp = lead(y) - 2*y + lag(y),
         acc.lp = sqrt(acc.x.lp^2 + acc.y.lp^2)*fr^2,
         t = (t-t[1])/1e6) %>%
  pivot_longer(c("vel.sg", "vel.sb", "acc.sg", "acc.lp"), names_to = c("metric", "filter"), names_sep = "[:punct:]", ) %>%
  mutate_at(c("metric", "filter"), as.factor) %>%
  dplyr::filter(t > 0.5, t < 1.5)

filter.comp$metric <- factor(filter.comp$metric, labels = c("Acceleration", "Velocity"))

ggplot(filter.comp, aes(x = t, y = value, color = filter)) + 
  geom_path() + facet_wrap(vars(metric), nrow = 2, scales = "free_y", strip.position = "left") + 
  scale_x_continuous(name = "Time (in s)") +
  scale_y_continuous(name = "") +
  scale_color_discrete(name = "Filter", labels = c("Laplace", "Sobel", "Savitzky-Golay")) +
  theme(strip.placement = "outside")
  

```


## The Generative Model
The generative model underlying gazeHMM is a multivariate hidden Markov model (HMM). It can contain between two and four states that correspond to different eye movement events: The first state always represents fixations, the second saccades, the third PSOs, and the fourth smooth pursuits. Thus, users can choose wether they would like to classify only fixations and saccades, or additionally PSOs and/or smooth puruits.  
In general, HMMs consist of three submodels: An initial state model, a transition model, and a response model [@Visser2019]. In gazeHMM, the response model consists of three response variables which are the velocity and acceleration signals obtained by the SG filter and the change in angle signal. The response variables are treated as conditionally independent on the states. I acknowledge that conditional independence might not accurately resemble the relationship between velocity and acceleration (which are naturally correlated). This step was merely taken to keep the HMM simple and identifyable.  
Previous algorithms using HMMs have used Gaussian distributions to describe velocity and acceleration signals (sometimes after log-transforming them). However, several reasons speak against choosing the Gaussian: First, both signals are usually positive (depending on the computation) and due to noise above zero. Second, the distributions of both signals appear to be positively skewed conditionally on the states and third, to have variances increasing with their mean. Thus, instead of using the Gaussian, it could be more appropriate to describe velocity and acceleration with a distribution that follows these three properties. In gazeHMM, I use gamma distributions with a shape and scale parametrization for this purpose. It has to be noted that the gamma was choosen out of convenience and the best fitting distribution might be different between eye-trackers, subjects, and tasks.   
To model the sample-to-sample angle, I pursued a novel approach in gazeHMM: Using a mixture of von-Mises distributions (with a mean and concentration parameter) and a uniform distribution. Both the distributions and the metric operate on the full unit circle (i.e., between 0 and $2\pi$) which should lead to rather symmetric distributions. Moreover, the uniform distribution can distinguish fixations from the other events.  
The initial state model and the transition model use multinomial distributions (with a category for each state). For all three submodels of the HMM, only parameter intercepts were estimated.

## Missing Data and Blinks
HMMs can estimate parameters and hidden states despite missing data. They either treat data as missing at random or as missing depending on states [@Visser2019]. In gazeHMM, I assume data to be missing at random. Most of the missing data in eye movement classification are due to blinks. The user can indicate in gazHMM which samples should be labeled as blinks (other missing samples are treated as noise). Often, eye-trackers record a few samples with unreasonably high velocity and acceleration before losing the pupil signal when a blink occurs. Since these samples could distort the classification of saccades in the HMM, I decided to remove them heuristically. Before classifying the samples, gazeHMM sets all samples within 50 ms before and after blink samples as missing. The window of 50 ms was rather motivated empirically than theoretically and can bet set to any value the user considers appropriate.  
When evaluating the likelihood of the HMM given parameters and the joint density of response distributions for missing data, the model integrates over all possible values. The resulting density for missing samples is therefore set to one [@Visser2019].

## Optimization and Classification
The paramters of the HMM are estimated through maximum likelihood using an expectation-maximization (EM) algorithm [@Dempster1977; @McLachlan1997]. The EM is generally suitable to estimate likelihoods with missing variables. For HMMs, it imputes missing with expected values and iteratively maximizes the joint likelihood of parameters conditional on the observed data (velocity, acceleration, and sample-to-sample angle) and the expected hidden states [eye movement events; @Visser2019]. The sequence of hidden states is estimated through the Viterbi algorithm [@Viterbi1967; @ForneyJr1973] by maximizing the posterior state probability. Parameters of the response distributions (except for the uniform distribution) were optimized on the log-scale (except for the mean parameter of the von-Mises distribution) using a spectral projected gradient method [@Birgin2000] and Barzilai-Borwein steplengths [@Barzilai1988].

## Postprocessing
After classifying gaze samples into states, gazeHMM applies a postprocessing routine to the estimated state sequence. I implemented this rountine because constraining the transition probabilities for PSOs to turn into non-saccade events to zero often caused PSOs not to appear in the state sequence at all. Moreover, gazeHMM did not explicitly control the duration of events in the HMM which ocassionally led to unreasonably short events. Thus, the postprocessing routine heuristically compensates for such violations. This routine relabels one-sample fixations and smooth pursuits, saccades with a duration below a minimum threshold, and PSOs that follow non-saccade events. Samples were relabeled as the state of the previous event. Finally, samples initially indicated as missing were labeled as noise (including blinks) and event metrics were computed (e.g., fixation durations).

## Implementation
The algorithm is implemented in R [version: 3.6.3; @RCoreTeam2020] and uses the packages signal [@Ligges2015] to compute velocity and acceleration signals, depmixS4 [@Visser2010] for the HMM, and BB [@Varadhan2009] for Barzilai-Borwein spectral projected gradient optimization. The algorithm is available on GitHub (www.github.com/maltelueken/gazeHMM).

# Simulation Study
To assess how well the HMM recovers parameters and state sequences, I conducted a simulation study. The design and analysis of the study were preregistered on the Open Science Framework (https://doi.org/10.17605/OSF.IO/VDJGP). The major part of this section is a direct copy of the preregistration. When appropriate, additional explanations were added and tenses adapted to make the design easier to read and understand.  
In the study, the HMM repeatedly generated data with a set of parameters (true parameter values). The same model was then be applied to estimate the parameters from the generated data (estimated parameter values). I compared the true with the estimated parameter values to assess whether a parameter was recovered by the model. Additionally, I compared the true states of the HMM with the estimated states to judge how accurately the model recovered the states that generated the data.

## Design
### Parameter Variation
The simulation study was divided into four parts. In the first part, I varied the parameters of the HMM. For models with $k \in \{2, 3, 4\}$ states, $q \in \{10, 15, 20\}$ parameters were varied respectively. For each parameter, the HMM generated 100 data sets with $N = 2500$ samples and the parameter varied in a specified interval in equidistant steps. This resulted in $100 \times (10+15+20) = 4500$ recoveries. Only one parameter was varied at once, the other parameters were set to their default values. All parameters of the HMM were estimated freely (i.e., there were no fixed parameters in the model). I did not manipulate the initial state probabilities because these are usually irrelevant in the context of eye movement classification. For the transition probabilities, I only simultaneously varied the probabilities for staying in the same state (diagonals of the tranistion matrix) to reduce the complexity of the simulation. The left over probability mass was split evenly between the probabilites for switching to a different state (per row of the transition matrix). Moreover, I did not modify the mean parameters of the von-Mises distributions: As location parameters, they do not alter the shape of the distribution and they are necessary features for the HMM to distinguish between different states.  
I defined approximate ranges for each response variable and chose true parameter intervals and default values so that they produced samples that roughly corresponded to these ranges. Table \@ref(tab:sim-ranges) shows the assumed ranges for each event and Tables \@ref(tab:sim-parameters-trans) and \@ref(tab:sim-parameters-resp) show the intervals and default values for each parameter in the simulation. Parameters were scaled down by factor 10 (compared to the reported ranges) to improve fitting of the gamma distributions. I set the intervals for shape parameters of the gamma distributions for all events to [1,5] to examine how skewness influenced the recovery (shape values above five approach a symmetric distribution). The scale parameters were set so that the respective distribution approximately matched the assumed ranges. Since the concentration parameters of the von-Mises distribution are the inverse of standard deviations, they were varied on the inverse scale.

### Sample Size and Noise Variation
In the second part, I varied the sample size of the generated data and the amount of noise added to it. The model parameters were set to their default values. For models with $k \in \{2, 3, 4\}$ states and sample sizes of $N \in \{500, 2500, 10000\}$, I generated 100 data sets ($100 \times 3 \times 3 = 900$ recoveries). These samples sizes roughly corresponded to small, medium, and large eye-tracking data sets for a single participant and trial. To simulate noise, I replaced velocity and acceleration values $y$ with draws from a gamma distribution with $\alpha_{noise} = 3$ and $\beta_{noise}=(y/2)\tau_{noise}$ with $\tau_{noise} \in [1,5]$ varying between data sets. This procedure ensured that velocity and acceleration values remained positive and were drawn from moderately skewed distributions with modes equal to the original values. To angle, I added white noise from a von-Mises distribution with $\mu_{noise} = 0$ and $\kappa_{noise} \in 1/[0.1,10]$ varying between data sets. $\tau_{noise}$ and $\kappa_{noise}$ were varied simultaneously in equidistant steps in their intervals.

### Variation of Starting Values
In the third part, I increased the variation in the starting values used for parameter estimation. The model parameters were set to their default values. For the shape, scale, and concentration parameters, I simultaneously increased the scale parameters of the starting value gamma distributions: For $k \in \{2, 3, 4\}$ states and $\beta_{start} = (\psi_{true}/2)\tau_{start}$ with $\tau_{start} \in \{1, 2, 3\}$, 100 data sets with $N = 2500$ samples were generated each ($100 \times 3 \times 3 = 900$ recoveries).

### Missing Data
In the last part, I set intervals of the generated data to be missing. The model parameters were set to their default values. For $k \in \{2, 3, 4\}$ states and $m \in \{1, 3, 5\}$ intervals, 100 data sets with $N = 2500$ samples were generated ($100 \times 3 \times 3 = 900$ recoveries). The length of the missing data interval $l \in [1,200]$ samples varied in equidistant steps between the data sets.

## Starting Values
The HMM always started with a uniform distribution to estimate the initial state and state transition probabilities. To generate random starting values for the estimation of shape, scale, and concentration parameters, I used gamma distributions with a shape parameter of $\alpha_{start}=3$ and $\beta_{start}=\psi_{true}/2$ with $\psi_{true}$ being the true value of the parameter to be estimated. This setup ensured that the starting values were positive, their distributions were moderately skewed, and the modes of their distributions equaled the true parameter values. Mean parameters of the von-Mises distribution always started at their true values.

## Data Analysis
For each parameter, I calculated the root median square proportion deviation [RMdSPD; analogous to root median square percentage errors, see @Hyndman2006] between the true and estimated parameter values[^1]: $$RMdSPD = \sqrt{Med((\frac{\psi_{true}-\psi_{est}}{\psi_{true}})^2)}.$$
I treated $RMdSPD < 0.1$ as good, $0.1 \le RMdSPD < 0.5$ as moderate, and $RMdSPD \ge 0.5$ as bad recovery of a parameter. By taking the median, I reduced the influence of potential outliers in the estimation and using proportions enabled me to compare RMdSPD values across parameters and data sets.  
Additionally, I applied a bivariate linear regression with the estimated parameter values as the dependent and the true parameter values as the independent variable to each parameter that has been varied on an interval in part one. Regression slopes closer to one indicated that the model better captured parameter change. Regression intercepts different from zero reflected a bias in parameter estimation.  
To assess state recovery, I computed Cohen's kappa (for all events taken together, not for each event separately) as a measure of agreement between true and estimated states for each generated data set. Higher kappa values were interpreted as better model accuracy. I adopted the ranges proposed by @Landis1977 to interpret kappa values.
Models that could not be fitted were excluded from the recovery.

[^1]: This measure is only appropriate when $\psi_{true} \ne 0$. This was not the case for some mean parameters of the von-Mises distributions. In those cases, I used $\psi_{true} = 2\pi$ instead.

(ref:sim-ranges) Approximate ranges of response variables used to generate parameter values
(ref:sim-ranges-note) Units are °/s (velocity), °/s^2^ (acceleration), and radians (angle). ~ indicates that the distribution has a peak at this value. Velocity ranges are based on event velocities reported in @Larsson2013. Since I would also like to test the algorithm on extreme data distributions, I extended the ranges beyond those found in typical eye movement data.

```{r, sim-ranges}

apa_table(data.frame("Event" = rep(c("Fixation", "Saccade", "PSO", "Smooth pursuit"), each = 3),
                     "Resp variable" = rep(c("Velocity", "Acceleration", "Angle"), 4),
                     "Range" = c("0-50", "0-50", "uniform", "50-1000", "50-500", "~0", "20-100", "10-90", paste("~", expression(pi), sep = ""), "20-100", "0-30", "~0")), 
          caption = "(ref:sim-ranges)",
          note = "(ref:sim-ranges-note)")

```

(ref:sim-parameters-trans) Intervals and default parameter values for the response models of the HMM in the simulation
(ref:sim-parameters-trans-note) The transition probability for staying in the same state is denoted by $a_{i=j}$ and the probability for switching to a different state by $a_{i\neq j}$. The number of states in the model is denoted by *k*.

```{r, sim-parameters-trans}

sim.pars.trans <- as.data.frame(matrix(c("Interval", "-", "[.01,.99]", "1-a(i=j)/(k-1)",
                                           "Default", "1/k", "0.9", "0.1/(k-1)"), nrow = 2, byrow = T))

apa_table(sim.pars.trans,
          col.names = c("", "Initial\nstate\nprob.", "Trans. prob.\nsame state", "Trans. prob.\nother state"),
          caption = "(ref:sim-parameters-trans)",
          note = "(ref:sim-parameters-trans-note)")

```

(ref:sim-parameters-resp) Intervals and default parameter values for the response models of the HMM in the simulation
(ref:sim-parameters-resp-note) Shape parameters are denoted by $\alpha$, scale parameters by $\beta$, mean parameters by $\mu$, and concentration parameters by $\kappa$. The default values for the uniform distribution in state one were min = 0 and max = $2\pi$.

```{r, sim-parameters-resp}

sim.pars.resp <- as.data.frame(t(matrix(c("[1,5]", "[0.1,0.6]", "[1,5]", "[0.05,0.25]", "-", "-", 
                                  "3", "0.35", "3", "0.25", "-", "-",
                                  "[1,5]", "[5,15]", "[1,5]", "[1,5]", "-", "1/[0.1,10]",
                                  "3", "10", "3", "3", "0", "1",
                                  "[1,5]", "[0.5,1.5]", "[1,5]", "[1,5]", "-", "1/[0.1,10]",
                                  "3", "1", "3", "3", paste(expression(pi), sep = ""), "1",
                                  "[1,5]", "[0.5,1.5]", "[1,5]", "[0.05,0.25]", "-", "1/[0.1,10]",
                                  "3", "1", "3", "0.15", "0", "1"), nrow = 6, byrow = F)))

apa_table(cbind(rep(c("Interval", "Default"), 4), sim.pars.resp),
          col.names = c("", "Shape", "Scale", "Shape", "Scale", "Mean", "Concentration"),
          col_spanners = list(Velocity = c(2, 3), Acceleration = c(4, 5), "Rel. angle" = c(6, 7)),
          stub_indents = list("State 1" = c(1, 2), "State 2" = c(3, 4), "State 3" = c(5, 6), "State 4" = c(7, 8)),
          caption = "(ref:sim-parameters-resp)",
          note = "(ref:sim-parameters-resp-note)")

```

```{r load sim results and helper functions, include=FALSE}

# Load simulation results

for (part in 1:4) {
  
  load(file = paste(here("simulation/part"), part, ".Rdata", sep = ""))
  
}


# Create functions to apply and invert mlogit link function (from depmixS4, Visser & Speekenbrink, 2019)

linkfun <- function(p, base) {
  lfun <- function(p, base) {
    p <- p/sum(p)
    beta <- numeric(length(p))
    if (any(p == 1)) 
      beta[which(p == 1)] = Inf
    else beta[-base] <- log(p[-base]/p[base])
    return(beta)
  }
  if (is.matrix(p)) {
    beta <- t(apply(p, 1, lfun, base = base))
  }
  else {
    beta <- lfun(p, base)
  }
  return(beta)
}

linkinv <- function(eta,base) {
  linv <- function(eta,base) {
    pp <- numeric(length(eta))
    if(any(is.infinite(eta)) || any(eta > log(.Machine$double.xmax)) || any(eta < log(.Machine$double.xmin))) {
      pp[which(is.infinite(eta))] <- 1
      pp[which(eta > log(.Machine$double.xmax))] <- 1 # change this to something better!
    } else {
      expb <- exp(eta)
      sumb <- sum(expb)
      pp[base] <- 1/sumb
      pp[-base] <- expb[-base]/sumb
    }
    return(pp)
  }
  if(is.matrix(eta)) {
    if(ncol(eta)==1) {
      pp <- as.matrix(apply(eta,1,linv,base=base)) # fixes problem with column matrix eta
    } else pp <- t(apply(eta,1,linv,base=base)) 	
  } else {
    pp <- linv(eta,base)
  }
  return(pp)
}


# Create function to transform parameters to normal scale

backtrans <- function(x) {
  
  out <- x
  
  nms <- names(x)
  
  out[str_detect(nms, "(Intercept)")] <- as.vector(apply(matrix(x[str_detect(nms, "(Intercept)")],
                                                        ncol = sqrt(length(x[str_detect(nms, "(Intercept)")])),
                                                        byrow = T), 1, linkinv, base = 1))
  
  out[nms %in% c("shape", "scale", "kappa")] <- exp(x[nms %in% c("shape", "scale", "kappa")])
  
  return(out)
}

```

```{r calculate RMdSPD, include=FALSE}

rmsd <- list()

for (part in 1:4) {
  
  rmsd[[part]] <- lapply(get(paste("estimates.", part, sep = "")), function(x) {
    lapply(x, function(y) {
      sqerr <- lapply(y, function(z) {
        
        err <- try(((backtrans(z$pars.est) - backtrans(z$pars.true))/
                      ifelse(backtrans(z$pars.true) == 0, 2*pi, backtrans(z$pars.true)))^2)
        
        if(is.numeric(err)) {
          
          out <- err
          
        } else {
          
          out <- rep(NA, length(z$pars.true))
          
        }
        
        names(out) <- names(z$pars.true)
        
        return(out)
      })
      
      rows <- length(sqerr)

      nms <- names(sqerr[[1]])

      pars <- matrix(unlist(sqerr), nrow = rows, byrow = T)
      
      msqerr <- apply(pars, 2, median, na.rm = T)
      
      names(msqerr) <- nms
      
      rmsqerr <- sqrt(msqerr)
      
      return(rmsqerr)
    })
  })
}


# Display RMdSPD in data frame

rmsd.data <- lapply(rmsd, function(x) lapply(x, as.data.frame))
rmsd.data <- lapply(rmsd.data, function(x) lapply(x, function(y) {as.data.frame(t(as.matrix(y)))}))
rmsd.data <- lapply(rmsd.data, function(x) lapply(1:length(x), function(y, data) {
  names(data[[y]]) <- names(rmsd[[1]][[y]][[1]])
  return(data[[y]])}, data = x))


# Create plots for part 1

plots.rmsd.1 <- lapply(rmsd.data[[1]], function(x) {
  
  names.pars.varied <- list(bquote(a["i=j"]), bquote(alpha["vel"]), bquote(beta["vel"]), bquote(alpha["acc"]),
                            bquote(beta["acc"]), bquote(kappa))
  
  if(ncol(x) == 18) {
    
    trnames <- list(bquote(rho["i"]), bquote(a["i1"]), bquote(a["i2"]))
    
  } else if(ncol(x) == 30) {
    
    trnames <- list(bquote(rho["i"]), bquote(a["i1"]), bquote(a["i2"]), bquote(a["i3"]))
    
  } else {
    
    trnames <- list(bquote(rho["i"]), bquote(a["i1"]), bquote(a["i2"]), bquote(a["i3"]), bquote(a["i4"]))
    
  }
  
  names.pars.est <- append(trnames, list(bquote(alpha["vel"]), bquote(beta["vel"]), bquote(alpha["acc"]),
                         bquote(beta["acc"]), bquote(mu), bquote(kappa)))
  
  x <- as_tibble(x, .name_repair = "unique")
  
  data.long <- x %>%
    mutate(par.varied = c(0, 1, 2, 3, 4, rep(c(1, 2, 3, 4, 5), (nrow(x) %/% 5)-1)),
           state.varied = c(1, rep(1, 4), rep(2:((nrow(x) %/% 5)), each = 5))) %>%
    pivot_longer(names(x), names_to = "par.est", values_to = "RMdSPD", names_repair = "unique") %>%
    mutate(state.est = rep(c(rep(1:max(state.varied), max(state.varied)+1),
                         rep(1:max(state.varied), each = 6)), nrow(x)),
           par.est = rep(c(rep(1, max(state.varied)), 
                           rep(2:(max(state.varied)+1), each = max(state.varied)), 
                           rep((max(state.varied)+2):(max(state.varied)+7), max(state.varied))), nrow(x))) %>%
    mutate_at(vars(par.varied, state.varied, par.est, state.est), as.factor)

  p <- ggplot(data = data.long, aes(x = par.varied, y = par.est, fill = RMdSPD)) +
    geom_tile() + facet_grid(cols = vars(state.varied), rows = vars(state.est)) +
    scale_x_discrete(name = "Varied parameter", labels = names.pars.varied) +
    scale_y_discrete(name = "Estimated parameter", labels = names.pars.est) +
    scale_fill_distiller(breaks = c(0, 0.1, 0.5, 1), palette = "Spectral")
  
  return(p)
})


# Create plots for parts 2,3, and 4

plots.rmsd.234 <- lapply(2:4, function(y, data) lapply(data[[y]], function(x) {
  
  if(ncol(x) == 18) {
    
    k <- 2
    
    trnames <- list(bquote(rho["i"]), bquote(a["i1"]), bquote(a["i2"]))
    
  } else if(ncol(x) == 30) {
    
    k <- 3
    
    trnames <- list(bquote(rho["i"]), bquote(a["i1"]), bquote(a["i2"]), bquote(a["i3"]))
    
  } else {
    
    k <-4
    
    trnames <- list(bquote(rho["i"]), bquote(a["i1"]), bquote(a["i2"]), bquote(a["i3"]), bquote(a["i4"]))
    
  }
  
  names.pars.est <- append(trnames, list(bquote(alpha["vel"]), bquote(beta["vel"]), bquote(alpha["acc"]),
                                         bquote(beta["acc"]), bquote(mu), bquote(kappa)))
  
  x <- as_tibble(x, .name_repair = "unique")
  
  data.long <- x %>%
    mutate(cond = 1:3) %>%
    pivot_longer(names(x), names_to = "par.est", values_to = "RMdSPD", names_repair = "unique") %>%
    mutate(state.est = rep(c(rep(1:k, k+1),
                             rep(1:k, each = 6)), nrow(x)),
           par.est = rep(c(rep(1, k), 
                           rep(2:(k+1), each = k), 
                           rep((k+2):(k+7), k)), nrow(x))) %>%
    mutate_at(vars(cond, par.est, state.est), as.factor)
  
  p <- ggplot(data = data.long, aes(x = par.est, y = RMdSPD, color = cond)) +
    geom_point(position = position_dodge(0.25)) + facet_grid(cols = vars(state.est)) +
    scale_x_discrete(name = "Estimated parameter", labels = names.pars.est) +
    scale_y_continuous(breaks = c(0.1, 0.5, 1, 1.5, 2)) +
    geom_hline(yintercept = 0.1, linetype = "dashed") +
    geom_hline(yintercept = 0.5, linetype = "dashed")
  
  if(y == 2) {
    names.cond <- c("500", "2500", "10000")
    label.cond <- "N"
  } else if (y == 3) {
    names.cond <- c("1", "2", "3")
    label.cond <- bquote(tau["start"])
  } else {
    names.cond <- c("1", "3", "5")
    label.cond <- "Number of\nintervals"
  }
  
  p <- p + scale_color_discrete(name = label.cond, labels = names.cond)
  
  return(p)
}), data = rmsd.data)

```

```{r calculate linear regressions, include=FALSE}

# Calculate regression weights for transition probabilities

regw.tr <- list()

regw.tr <- lapply(get("estimates.1"), function(x) {
  
  varpar <- lapply(x[1], function(y) {
    
    lapply(y, function(z) {
      
      nms <- names(z$pars.true)
      
      pars.tr <- logical(length(z$pars.true))
      
      pars.tr[str_detect(nms, "(Intercept)")] <- T
      
      intpar <- try(cbind(backtrans(z$pars.true[pars.tr]), backtrans(z$pars.est[pars.tr])))
      
      if(is.numeric(intpar)) {
        out <- intpar
      } else {
        out <- matrix(NA, nrow = length(z$pars.true[pars.tr]), ncol = 2)
      }
      
      out <- apply(out, 1, list)
      
      return(out)
    })
  })
  
  df <- list()
  
  for (i in 1:length(varpar[[1]][[1]])) {
    
    df[[i]] <- lapply(varpar, function(y, index) {
      
      lapply(y, function(z) {z[[index]]})
      
    }, index = i)
  }
  
  df <- lapply(df, as.data.frame)

  df <- lapply(df, function(z) {
    
    out <- as.data.frame(t(as.matrix(z)))
    
    names(out) <- c("true", "est")
    
    return(out)
  })
})


# Calculate linear regression weights for response parameters

regw.resp <- list()
  
regw.resp <- lapply(get("estimates.1"), function(x) {
  
  index <- 1:length(x[-1])
  
  varpar <- lapply(index, function(i, y) {
    
    lapply(y[[i]], function(z) {
      
      nms <- names(z$pars.true)
      
      #pars.tr <- logical(length(z$pars.true))
      pars.resp <- logical(length(z$pars.true))
      
      #pars.tr[str_detect(nms, "(Intercept)")] <- T
      pars.resp[nms %in% c("shape", "scale", "kappa")] <- T
      
      intpar <- try(c(backtrans(z$pars.true[pars.resp][i]), backtrans(z$pars.est[pars.resp][i])))
      
      if(is.numeric(intpar)) {
        return(intpar)
      } else {
        return(rep(NA, 2))
      }
    })
  }, y = x[-1])
  
  df <- lapply(varpar, as.data.frame)
  df <- lapply(df, function(z) {

    out <- as.data.frame(t(as.matrix(z)))

    names(out) <- c("true", "est")

    return(out)
  })
})


# Plot linear regressions for transition probabilities

D <- 100

regw.tr.data <- lapply(regw.tr, function(x) lapply(x, function(y) rbind(y)))
regw.tr.data <- lapply(regw.tr.data, function(x) reduce(x, rbind))

plots.lm.tr <- lapply(1:length(regw.tr.data), function(x, y) {
  
  data <- y[[x]] %>% 
    mutate(par = rep(1:(x+1)^2, each = D),
           from = rep(rep(1:(x+1), each = D), x+1),
           to = rep(1:(x+1), each = D*(x+1)))
  
  p <- ggplot(data, aes(x = true, y = est)) + 
    facet_grid(rows = vars(from), cols = vars(to), labeller = label_both) +
    geom_point() + geom_smooth(method = "lm") +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    scale_x_continuous(name = "True transition probability") +
    scale_y_continuous(name = "Estimated transition probability")
  
  return(p)
}, y = regw.tr.data)


# Plot linear regressions for response parameters

regw.resp.data <- lapply(regw.resp, function(x) lapply(x, function(y) rbind(y)))
regw.resp.data <- lapply(regw.resp.data, function(x) reduce(x, rbind))

parnames <- list(bquote(alpha["vel;1"]), bquote(beta["vel;1"]), bquote(alpha["acc;1"]), bquote(beta["acc;1"]),
                 bquote(alpha["vel;2"]), bquote(beta["vel;2"]), bquote(alpha["acc;2"]), bquote(beta["acc;2"]), bquote(kappa["2"]),
                 bquote(alpha["vel;3"]), bquote(beta["vel;3"]), bquote(alpha["acc;3"]), bquote(beta["acc;3"]), bquote(kappa["3"]),
                 bquote(alpha["vel;4"]), bquote(beta["vel;4"]), bquote(alpha["acc;4"]), bquote(beta["acc;4"]), bquote(kappa["4"]))

plots.lm.resp <- lapply(regw.resp.data, function(x) {
  
  npar <- nrow(x) %/% D
  
  data <- x %>% 
    mutate(par = rep(1:npar, each = D),
           type = rep(1, 2, 1, 2))
  
  p <- ggplot(data, aes(x = true, y = est)) + 
    facet_wrap(vars(par), scales = "free", labeller = label_bquote(.(parnames[[par]]))) +
    geom_point() + geom_smooth(method = "lm") +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    scale_x_continuous(name = "True transition probability") +
    scale_y_continuous(name = "Estimated transition probability")
  
  return(p)
})

```

```{r calculate accuracy, include=FALSE}

# Summarise accuracy

acc.data <- list()

for (part in 1:4) {
  
  acc.data[[part]] <- lapply(get(paste("estimates.", part, sep = "")), function(x) {
    out <- lapply(x, function(y) { 
      out <- lapply(y, function(z) {
        
        if(is.numeric(z$accuracy)) {
          acc <- z$accuracy
        } else {
          acc <- NA
        }
        
        return(acc)
      })
      
      return(as.vector(reduce(out, cbind)))
    })
    
    return(as.data.frame(t(reduce(out, cbind))))
  })
}

# Plot accuracy part 1

plots.acc.1 <- lapply(acc.data[[1]], function(x) {
  
  names.pars.varied <- list(bquote(a["i=j"]), bquote(alpha["vel"]), bquote(beta["vel"]), bquote(alpha["acc"]),
                            bquote(beta["acc"]), bquote(kappa))
  
  x <- as_tibble(x, .name_repair = "unique")
  
  data.long <- x %>%
    mutate(par.varied = c(0, 1, 2, 3, 4, rep(c(1, 2, 3, 4, 5), (nrow(x) %/% 5)-1)),
           state.varied = c(1, rep(1, 4), rep(2:((nrow(x) %/% 5)), each = 5))) %>%
    pivot_longer(names(x), names_to = "par.est", values_to = "accuracy") %>%
    mutate_at(vars(par.varied, state.varied), as.factor)
  
  p <- ggplot(data = data.long, aes(x = par.varied, y = accuracy)) +
    geom_boxplot(outlier.shape = 4) + facet_grid(cols = vars(state.varied)) +
    scale_x_discrete(name = "Varied parameter", labels = names.pars.varied) + 
    scale_y_continuous(name = "Cohen's kappa", breaks = c(-1, -0.33, 0, 0.25, 0.5, 0.75, 1))
  
  return(p)
})


# Plot accuracy parts 2, 3, and 4

acc.data.234 <- lapply(acc.data[2:4], function(x) reduce(x, rbind))

plots.acc.234 <- lapply(1:3, function(y, data) {
  
  x <- as_tibble(data[[y]], .name_repair = "unique")
  
  data.long <- x %>%
    mutate(cond = as.factor(rep(1:3, 3)),
           k = as.factor(rep(2:4, each = 3))) %>%
    pivot_longer(names(x), names_to = "par.est", values_to = "accuracy")
  
  p <- ggplot(data = data.long, aes(x = k, y = accuracy, color = cond)) +
    geom_boxplot(outlier.shape = 4) + 
    scale_x_discrete(name = "k (number of states)")  + 
    scale_y_continuous(name = "Cohen's kappa", breaks = c(-1, -0.33, 0, 0.25, 0.5, 0.75, 1))
  
  if(y == 1) {
    names.cond <- c("500", "2500", "10000")
    label.cond <- "N"
  } else if (y == 2) {
    names.cond <- c("1", "2", "3")
    label.cond <- bquote(tau["start"])
  } else {
    names.cond <- c("1", "3", "5")
    label.cond <- "Number of\nintervals"
  }
  
  p <- p + scale_color_discrete(name = label.cond, labels = names.cond)
  
  return(p)
}, data = acc.data.234)


# Plot accuracy over interval parts 2 and 4

plots.acc.int.24 <- lapply(c(1, 3), function(y, data) {
  
  x <- as_tibble(data[[y]], .name_repair = "unique")
  
  if(y == 1) {
  
    int <- rep(seq(1, 5, length.out = D), 9) 
  
  } else {
    
    int <- rep(floor(seq(1, 200, length.out = D)), 9)
    
  }
  
  data.long <- x %>%
    mutate(cond = as.factor(rep(1:3, 3)),
           k = as.factor(rep(2:4, each = 3))) %>%
    pivot_longer(names(x), names_to = "par.est", values_to = "accuracy") %>%
    mutate(int = int)
  
  p <- ggplot(data = data.long, aes(x = int, y = accuracy, color = cond)) +
    facet_grid(cols = vars(k), labeller = label_both) + 
    geom_point()
  
  if(y == 1) {
    names.cond <- c("500", "2500", "10000")
    label.cond <- "N"
    x.name <- bquote(tau["noise"])
  } else {
    names.cond <- c("1", "3", "5")
    label.cond <- "Number of\nintervals"
    x.name <- "Interval length (in samples)"
  }
  
  p <- p + scale_color_discrete(name = label.cond, labels = names.cond) +
    scale_x_continuous(name = x.name) + 
    scale_y_continuous(name = "Cohen's kappa", breaks = c(-1, -0.33, 0, 0.25, 0.5, 0.75, 1))
  
  return(p)
}, data = acc.data.234)


# Exploratory analysis for label switching

load(paste(dir, "simulation/part3_expl.Rdata", sep = "/"))

labsw <- lapply(1:length(estimates.3), function(x) {
  out <- lapply(estimates.3[[x]], function(y) {
    out <- lapply(y, function(z) {
      
      kappa <- try(cohen.kappa(z$states)$kappa)
      
      states <- z$states
      
      if(x == 2 & is.numeric(kappa) & kappa < 0.95) {
          
        states$y <- ifelse(z$states$y == 3, 2, ifelse(z$states$y == 2, 3, z$states$y))
          
        kappa <- cohen.kappa(states)$kappa
        
        if(is.numeric(kappa) & kappa < 0.95) {
          
          states$y <- ifelse(z$states$y == 3, 1, ifelse(z$states$y == 1, 3, z$states$y))
          
          kappa <- cohen.kappa(states)$kappa
        }
        
        if(is.numeric(kappa) & kappa < 0.95) {
          
          states$y <- ifelse(z$states$y == 3, 2, ifelse(z$states$y == 1, 3, 1))
          
          kappa <- cohen.kappa(states)$kappa
        }
      }
      
      if(x == 3 & is.numeric(kappa) & kappa < 0.5) {
        
        states$y <- ifelse(z$states$y == 3, 2, ifelse(z$states$y == 2, 3, z$states$y))
        
        kappa <- cohen.kappa(states)$kappa
        
        if(is.numeric(kappa) & kappa < 0.5) {

          states$y <- ifelse(z$states$y == 3, 4, ifelse(z$states$y == 4, 3, z$states$y))

          kappa <- cohen.kappa(states)$kappa
        }

        if(is.numeric(kappa) & kappa < 0.5) {

          states$y <- ifelse(z$states$y == 3, 1, ifelse(z$states$y == 1, 3, z$states$y))

          kappa <- cohen.kappa(states)$kappa
        }
        
        if(is.numeric(kappa) & kappa < 0.5) {
          
          kappa <- cohen.kappa(z$states)$kappa
        }
      }
      
      if(is.numeric(kappa)) {return(kappa)
        } else {return(NA)}
    })
    
    return(as.vector(reduce(out, cbind)))
  })
  
  return(t(reduce(out, cbind)))
})

labsw.df <- as.data.frame(reduce(labsw, rbind))


# Plot exploratory analysis results

plots.acc.expl <- lapply(1, function(y, data) {
  
  x <- as_tibble(data, .name_repair = "unique")
  
  data.long <- x %>%
    mutate(cond = as.factor(rep(1:3, 3)),
           k = as.factor(rep(2:4, each = 3))) %>%
    pivot_longer(names(x), names_to = "par.est", values_to = "accuracy")
  
  p <- ggplot(data = data.long, aes(x = k, y = accuracy, color = cond)) +
    geom_boxplot(outlier.shape = 4) + 
    scale_x_discrete(name = "k (number of states)")  + 
    scale_y_continuous(name = "Cohen's kappa", breaks = c(-1, -0.33, 0, 0.25, 0.5, 0.75, 1))
  
  names.cond <- c("1", "2", "3")
  label.cond <- bquote(tau["start"])
  
  p <- p + scale_color_discrete(name = label.cond, labels = names.cond)
  
  return(p)
}, data = labsw.df)


```

# Exploratory Results
## Simulation Study
### Parameter Variation
#### Two States
In the first part of the simulation, I examined how varying the parameters in the HMM affects the deviation and accuracy between the true and estimated parameters and state sequence. Figure \@ref(fig:plot-rmdspd-1-2) displays the RMdSPD between true and estimated parameters depending on which parameter has been manipulated in the HMM. The RMdSPD was below 0.1 for all estimated and manipulated parameters, that is, the median deviation never exceeded 10% of the true parameters [^2]. The regressions between manipulated true and estimated parameters are shown in Figures \@ref(fig:plot-regtr-1-2) and \@ref(fig:plot-regresp-1-2). With one outlier at parameter $\alpha_{acc;1}$, the estimated parameters matched the true parameters very closely. The deviation seemed to increase slighlty with parameter magnitude. Considering accuracy, Figure \@ref(fig:plot-acc-1-2) displays Cohen's kappa between true and estimated hidden state sequences. With two exceptions, kappa values were almost one, indicating nearly perfect agreement. In sum, the HMM with two states recovered parameters and hidden states very well and outliers only occured rarely.  

[^2]: Note that the intial state probability $\rho_i$ has also been estimated. Since the HMM only simulated one state sequence, this parameter is always either zero or one (leading to an RMdSPD of one). Therefore, I decided not to include it in the analysis.

(ref:plot-rmdspd-1-2) RMdSPD between true and estimated parameters of the two-state HMM in part one of the simulation. Labels on the x-axis indicate which true parameters have been manipulated and labels on the y-axis show for which estimated parameter the RMdSPD is displayed. Top facet labels specify in which state the parameters have been varied and right facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-1-2, fig.cap="(ref:plot-rmdspd-1-2)"}

print(plots.rmsd.1[[1]])

```

(ref:plot-regtr-1-2) Regression lines between true and estimated transition probabilities for the two-state HMM in part one. Top facet labels show to and right facet labels show from which state the HMM is moving. 

```{r plot-regtr-1-2, fig.cap="(ref:plot-regtr-1-2)"}

print(plots.lm.tr[[1]])

```

(ref:plot-regresp-1-2) Regression lines between true and estimated transition response parameters of the two-state HMM in part one. Top facet labels indicate response parameters.

```{r plot-regresp-1-2, fig.cap="(ref:plot-regresp-1-2)"}

print(plots.lm.resp[[1]] + theme(axis.text = element_text(size = 10)))

```

(ref:plot-acc-1-2) Boxplots displaying Cohen's kappa depending on which parameter of the two-state HMM has been manipulated in part one. Top facet labels indicate for which state parameters have been manipulated. Black solid lines symbolize medians. Crosses represent outliers (distance to first/third quartile higher than 1.5 times the inter-quartile range [IQR]).

```{r, plot-acc-1-2, fig.cap="(ref:plot-acc-1-2)"}

print(plots.acc.1[[1]])

```

#### Three States
For the simulation with three states, the RMdSPD is shown in Figure \@ref(fig:plot-rmdspd-1-3). When response parameters (other than $a_{i=j}$) were manipulated, the RMdSPDs for $a_{12}$ and $a_{31}$ were consistently below 0.5. Varying $\kappa$ in states two and three led to RMdSPDs below 0.5 in the respective states. Otherwise, RMdSPDs were consistently lower than 0.1, indicating a median deviation between true and estimated parameters below 10% of the true parameter. Inspecting the regressions between manipulated true and estimated parameters (see Figures \@ref(fig:plot-regtr-1-3) and \@ref(fig:plot-regresp-1-3)) revealed strong and unbiased linear relationships (intercepts close to zero and slopes close to one). Again, the deviation seemed to increase with true parameter magnitude (reverse for kappas). In contrast to the two-state HMM, larger deviatons and more outliers were observed. Cohen's kappa values for the three-state HMM are presented in Figure \@ref(fig:plot-acc-1-3). For most estimated models, the kappas between true and estimated state sequences were above 0.95, indicating almost perfect agreement. However, for some models, I observed kappas clustered around zero or -0.33, suggesting that state labels switched. To summarize, the three-state HMM had a slightly worse parameter recovery and more outliers than the two-state model but shows a similar good accuracy.  

(ref:plot-rmdspd-1-3) RMdSPD between true and estimated parameters of the three-state HMM in part one of the simulation. Labels on the x-axis indicate which true parameters have been manipulated and labels on the y-axis show for which estimated parameter the RMdSPD is displayed. Top facet labels specify in which state the parameters have been varied and right facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-1-3, fig.cap="(ref:plot-rmdspd-1-3)"}

print(plots.rmsd.1[[2]]+ theme(axis.text = element_text(size = 8)))

```

(ref:plot-regtr-1-3) Regression lines between true and estimated transition probabilities for the three-state HMM in part one. Top facet labels show to and right facet labels show from which state the HMM is moving. 

```{r plot-regtr-1-3, fig.cap="(ref:plot-regtr-1-3)"}

print(plots.lm.tr[[2]])

```

(ref:plot-regresp-1-3) Regression lines between true and estimated transition response parameters of the three-state HMM in part one. Top facet labels indicate response parameters.

```{r plot-regresp-1-3, fig.cap="(ref:plot-regresp-1-3)", fig.height=7}

print(plots.lm.resp[[2]] + theme(axis.text = element_text(size = 8)))

```

(ref:plot-acc-1-3) Boxplots displaying Cohen's kappa depending on which parameter of the three-state HMM has been manipulated in part one. Top facet labels indicate for which state parameters have been manipulated. Black solid lines symbolize medians and hinges the first and third quartile. Whiskers range from hinges to lowest/highest value within 1.5 times the IQR. Crosses represent outliers.

```{r, plot-acc-1-3, fig.cap="(ref:plot-acc-1-3)"}

print(plots.acc.1[[2]])

```

#### Four States
The RMdSPDs for the four-state HMM is illustrated in Figure \@ref(fig:plot-rmdspd-1-4). For estimated transition probabilities and $\alpha_{vel}$ and $\beta_{vel}$ parameters in states one and four, RMdSPDs were below 0.5. Estimated kappa parameters in smooth pursuits were also often below 0.5 when paramteres in states two, three, and four were varied. Otherwise, RMdSPDs were below 0.1, indicating a median deviation below 10% of the true parameter. Looking at the regressions between true and estimated paramters, Figures \@ref(fig:plot-regtr-1-4) and \@ref(fig:plot-regresp-1-4) show strong and unbiased relationships. However, there were larger deviations and more outliers than in the previous models, especially for states one and four. Accuracy measured by Cohen's kappa ranged between 0.6 and 0.9 for the majority of models, meaning moderate to almost perfect agreement between true and estimated state sequences (see Figure \@ref(fig:plot-acc-1-4)). Here, some kappa values clustered around 0.25 and zero, which again can be interpreted as the result of label switching. Summarizing, the parameter recovery for the four-state HMM was slightly worse with even more outliers compared to the three-state model. Especially the recovery of transition parameters in states corresponding to fixations and smooth pursuits decreased.  
Overall, simulations in part one demonstrated that the HMM recovered parameters at least moderately well when parameters were manipulated (all RMdSPDs below 0.5). The HMM estimated state sequences very accurately. Adding states to the model decreased the accuracy and recovery slightly, leading to more outliers, especially when smooth pursuits were added.

(ref:plot-rmdspd-1-4) RMdSPD between true and estimated parameters of the four-state HMM in part one of the simulation. Labels on the x-axis indicate which true parameters have been manipulated and labels on the y-axis show for which estimated parameter the RMdSPD is displayed. Top facet labels specify in which state the parameters have been varied and right facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-1-4, fig.cap="(ref:plot-rmdspd-1-4)"}

print(plots.rmsd.1[[3]] + theme(axis.text = element_text(size = 6)))

```

(ref:plot-regtr-1-4) Regression lines between true and estimated transition probabilities for the four-state HMM in part one. Top facet labels show to and right facet labels show from which state the HMM is moving. 

```{r plot-regtr-1-4, fig.cap="(ref:plot-regtr-1-4)", fig.height=8}

print(plots.lm.tr[[3]] + theme(axis.text = element_text(size = 8)))

```

(ref:plot-regresp-1-4) Regression lines between true and estimated transition response parameters of the four-state HMM in part one. Top facet labels indicate response parameters.

```{r plot-regresp-1-4, fig.cap="(ref:plot-regresp-1-4)", fig.height=8}

print(plots.lm.resp[[3]] + theme(axis.text = element_text(size = 6)))

```

(ref:plot-acc-1-4) Boxplots displaying Cohen's kappa depending on which parameter of the four-state HMM has been manipulated in part one. Top facet labels indicate for which state parameters have been manipulated. Black solid lines symbolize medians and hinges the first and third quartile. Whiskers range from hinges to lowest/highest value within 1.5 times the IQR. Crosses represent outliers.

```{r, plot-acc-1-4, fig.cap="(ref:plot-acc-1-4)"}

print(plots.acc.1[[3]] + theme(axis.text = element_text(size = 8)))

```

### Sample Size and Noise Variation
#### Two States
In the second part, I varied the sample size of the HMM and added noise to the generated data. For the two-state HMM, the RMdSPDs were above 0.5 for $\beta_{vel}$ and $\beta_{acc}$ in both states (see Figure \@ref(fig:plot-rmdspd-2-2)). The other estimated parameters showed RMdSPDs close to or below 0.1. Increasing the sample size seemed to improve RMdSPDs for most parameters slightly. For $\beta_{vel}$ and $\beta_{acc}$ in both states, models with 2500 samples had the lowest RMdSPDs. Accuracy measured by Cohen's kappa was almost perfect with kappa values very close to one (see Figure \@ref(fig:plot-acc-2), left plot). To conclude, adding noise did not affect the parameter recover or accuracy of the two-state HMM, whereas increasing the sample size improved the recovery slightly.  

(ref:plot-rmdspd-2-2) RMdSPD between true and estimated parameters of the two-state HMM in part two of the simulation. Colours indicate different sizes of generated data. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-2-2, fig.cap="(ref:plot-rmdspd-2-2)"}

print(plots.rmsd.234[[1]][[1]] + theme(axis.text = element_text(size = 10)))

```

(ref:plot-acc-2) Cohen's kappa depending on the variation of noise added to the data generated by the HMM. Colours indicate different sizes of generated data. Top facet labels indicate the number of states in the HMM.

```{r, plot-acc-2, fig.cap="(ref:plot-acc-2)"}

print(plots.acc.int.24[[1]])

```

#### Three States
The RMdSPDs for the $\beta_{vel}$ and $\beta_{acc}$ were above 0.5 in all three states (see Figure \@ref(fig:plot-rmdspd-2-3)). Again, the other estimated parameters were below or close to 0.1, only $a_{12}$ and $a_{31}$ with 500 samples were closer to 0.5. For most parameters across all three states, higher sample sizes had lower RMdSPDs. The accuracy of the estimated models was almost perfect with most kappa values above 0.95 (see Figure \@ref(fig:plot-acc-2), middle plot). Several outliers clustered around kappas of zero and -0.33, signaling label switching. For the three-state HMM, adding noise led to a slightly worse recovery and accuracy overall. However, scale parameters of gamma distributions in all three states were only badly recovered.  

(ref:plot-rmdspd-2-3) RMdSPD between true and estimated parameters of the three-state HMM in part two of the simulation. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-2-3, fig.cap="(ref:plot-rmdspd-2-3)"}

print(plots.rmsd.234[[1]][[2]] + theme(axis.text = element_text(size = 8)))

```

#### Four States
RMdSPDs regarding the four-state HMM are displayed in Figure \@ref(fig:plot-rmdspd-2-4). For states one and four, values for most parameters (including all transition probabilites) were above 0.5. Similarly, RMdSPDs for $\beta_{vel}$ and $\beta_{acc}$ in states two and three were above 0.5. For states two and three, higher samples sizes showed slightly lower RMdSPDs. As in the previous part, most Cohen's kappa values ranged between 0.6 and 0.9, meaning substantial to almost perfect agreement between true and estimated states (Figure \@ref(fig:plot-acc-2), right plot). Multiple kappa values clustered around 0.25 or zero, which can be explained by label switching. In summary, adding noise to data generated by the four-state HMM heavily decreased the recovery for most parameters in states corresponding to fixations and smooth pursuits. For saccade and PSO states, only scale parameters of gamma distributions were badly recovered, but increasing the sample size slightly improved the recovery.  
In general, the HMM recovered parameters well despite noise being added to the data. However, when smooth pursuits were added to the model, the parameter recovery for fixation and smooth pursuit states substantially decreased. When PSOs or smooth pursuits were included, scale parameters of gamma distributions were badly recovered. Increasing the samples in the HMM slightly improved the recovery of most parameters. The accuracy of the model was slightly lowered when including more states, but it was neither affected by the noise variability $\tau_{noise}$ nor the sample size.

(ref:plot-rmdspd-2-4) RMdSPD between true and estimated parameters of the three-state HMM in part two of the simulation. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-2-4, fig.cap="(ref:plot-rmdspd-2-4)"}

print(plots.rmsd.234[[1]][[3]] + theme(axis.text = element_text(size = 6)))

```


### Variation of Starting Values
The third part of the simulation investigated how increasing the variation in generating starting values affected parameter recover and accuracy of the HMM. For the two-state HMM, all parameters displayed RMdSPDs lower than 0.1 (see Figure \@ref(fig:plot-rmdspd-3-2)). Cohen's kappa values were slightly lower than 1, indicating almost perfect accuracy (see Figure \@ref(fig:plot-acc-3)). For the three-state HMM, RMdSPDs were lower than 0.1 except for $a_{12}$ and $a_{31}$, which were below 0.5 (see Figure \@ref(fig:plot-rmdspd-3-3)). As in previous parts, Cohen's kappa values were mostly above 0.95 (almost perfect accuracy) with exceptions clustering around zero and -0.33 (see Figure \@ref(fig:plot-acc-3)). Regarding the four state-HMM, RMdSPS of transition probabilities for states one and four were clustered above 0.1, other estimated parameters in the model showed values below 0.1 (see Figure \@ref(fig:plot-rmdspd-3-4)). The HMM showed substantial to almost perfect accuracy, as Cohen's kappa values were mostly above 0.8 with a few values clustering around 0.6, 0.25, and zero (see Figure \@ref(fig:plot-acc-3)). In conclusion, the parameter recovery of the model worked very well. State sequences were accurately estimated and more states being included in the model slightly decreased the accuracy. Increasing the variation in starting values for parameter estimation did neither affect the parameter recovery nor accuracy.  

(ref:plot-rmdspd-3-2) RMdSPD between true and estimated parameters of the two-state HMM in part three of the simulation. Colours indicate the variation in starting values used to estimate parameters. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-3-2, fig.cap="(ref:plot-rmdspd-3-2)"}

print(plots.rmsd.234[[2]][[1]] + theme(axis.text = element_text(size = 10)))

```

(ref:plot-acc-3) Boxplots displaying Cohen's kappa depending on the number of states in the HMM in part three. Colours indicate the variation in starting values used to estimate parameters. Solid vertical lines symbolize medians and hinges the first and third quartile. Whiskers range from hinges to lowest/highest value within 1.5 times the IQR. Crosses represent outliers.

```{r plot-acc-3, fig.cap="(ref:plot-acc-3)"}

print(plots.acc.234[[2]] + theme(axis.text = element_text(size = 8)))

```

(ref:plot-rmdspd-3-3) RMdSPD between true and estimated parameters of the three-state HMM in part three of the simulation. Colours indicate the variation in starting values used to estimate parameters. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-3-3, fig.cap="(ref:plot-rmdspd-3-3)"}

print(plots.rmsd.234[[2]][[2]] + theme(axis.text = element_text(size = 8)))

```

(ref:plot-rmdspd-3-4) RMdSPD between true and estimated parameters of the four-state HMM in part three of the simulation. Colours indicate the variation in starting values used to estimate parameters. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-3-4, fig.cap="(ref:plot-rmdspd-3-4)"}

print(plots.rmsd.234[[2]][[3]] + theme(axis.text = element_text(size = 6)))

```

In this part, I explored post-hoc whether clusters of low Cohen's kappa values were due to label switching. According to Visser and Speekenbrink [-@Visser2019], label switching occurs when exchanging the order of the states leads to equally likely models. Thus, the model is accurate but has oppositely estimated states compared to the true states. In this case, an HMM with three states that is perfectly accurate but has one label swtiched would have a Cohen's kappa of 0. To test if label switching occured, I manually switched one or two labels post-hoc (see Figure \@ref(fig:plot-acc-3-expl)). It can be seen that this approach resolved low accuracy clusters for three and four states.

(ref:plot-acc-3-expl) Boxplots displaying Cohen's kappa depending on the number of states in the HMM in part three after state labels were switched post-hoc (exploratory analysis). Colours indicate the variation in starting values used to estimate parameters. Solid vertical lines symbolize medians and hinges the first and third quartile. Whiskers range from hinges to lowest/highest value within 1.5 times the IQR. Crosses represent outliers.

```{r plot-acc-3-expl, fig.cap="(ref:plot-acc-3-expl)"}

print(plots.acc.expl[[1]] + theme(axis.text = element_text(size = 8)))

```

### Missing Data
In the last part, data intervals of varying length were set to be missing. Regarding parameter recovery, RMdSPDs were almost exactly mirroring those in the previous part for two, three, and four states (see Figures \@ref(fig:plot-rmdspd-4-2), \@ref(fig:plot-rmdspd-4-3), and \@ref(fig:plot-rmdspd-4-4), respectively). Looking at accuracies, Figure \@ref(fig:plot-acc-4) illustrates an interaction between the length of and amount of missing data intervals. Cohen's kappa values linearly decreased with the length of missing data intervals and the decrease became linearly steeper when more intervals were included. For two and three state models, kappas started at almost one and decreased to 0.6 for five missing intervals, indicating substantial to almost perfect accuracy. For the four-state model, kappas started around 0.85 and decreased to 0.5 for five missing intervals, suggesting moderate to substantial accuracy. As in previous parts, a several kappa values clustered around zero and -0.33 for the three-state model and around 0.6, 0.25, and zero for the four-state model. In total, missing data did not affect the parameter recovery but linearly decreased the accuracy of the model from an nearly perfect to a moderate extent.  
With a few exceptions, the simulation study revealed that the HMM recovered parameters well and accurately estimated the true state sequences. The most critical decrease in recovery occured when noise was added to the data generated by models including smooth pursuit. In the noise condition, scale parameters of gamma distributions were often badly recovered. Higher sample sizes slightly improved parameter recovery, but neither variation in starting values nor missing data affected it. In contrast, the accuracy of the model was linearly descreasing with more data missing but not influenced by manipulating parameters, noise, or starting value variation. Adding more states to the HMM generally decreased the parameter recovery and the accuracy.

(ref:plot-rmdspd-4-2) RMdSPD between true and estimated parameters of the two-state HMM in part four of the simulation. Colours indicate the number of missing data intervals. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-4-2, fig.cap="(ref:plot-rmdspd-4-2)"}

print(plots.rmsd.234[[3]][[1]] + theme(axis.text = element_text(size = 10)))

```

(ref:plot-rmdspd-4-3) RMdSPD between true and estimated parameters of the three-state HMM in part four of the simulation. Colours indicate the number of missing data intervals. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-4-3, fig.cap="(ref:plot-rmdspd-4-3)"}

print(plots.rmsd.234[[3]][[2]] + theme(axis.text = element_text(size = 8)))

```

(ref:plot-rmdspd-4-4) RMdSPD between true and estimated parameters of the four-state HMM in part four of the simulation. Colours indicate the number of missing data intervals. Labels on the x-axis indicate for which estimated parameter the RMdSPD is displayed. Top facet labels denote to which state estimated parameters belong.

```{r plot-rmdspd-4-4, fig.cap="(ref:plot-rmdspd-4-4)"}

print(plots.rmsd.234[[3]][[3]] + theme(axis.text = element_text(size = 6)))

```

(ref:plot-acc-4) Cohen's kappa depending on the length of missing data intervals. Colours indicate the number of missing data intervals. Top facet labels indicate the number of states in the HMM.

```{r, plot-acc-4, fig.cap="(ref:plot-acc-4)"}

print(plots.acc.int.24[[2]])

```

## Validation
### Starting Values and Model Fitting
I applied gazeHMM on two benchmark data sets to test my hypotheses. For both data sets, I used the same set of starting values (initial state model: $\rho=1/k$; transition model: $a_{i=j}=0.9$ and $a_{i\neq j}=0.1/k$; response model: see Table \@ref(tab:tab-starting-values)) to estimate the parameters of the HMM. In contrast to the simulation study, generating random starting value often led to bad model fits and label switching between states. To improve the fitting of the gamma distributions, velocity and acceleration signals were scaled down by factor 100 (so were the starting values for their gamma distributions). The algorithm was applied separately for every participant and every condition. For the data set by @Andersson2017, the algorithm was successfully fitted for every participant and condition.

(ref:tab-starting-values) Starting values for response models in fitting gazeHMM to benchmark data sets
(ref:tab-starting-values-note) Starting values for velocity and acceleration signals are shown before scaling down by factor 100. Values for event 5 were chosen so that they approximately match plausible distributions for microsaccades.

```{r tab-starting-values}

tab.start <- as.data.frame(matrix(c(10, 10, 10, 10, NA, NA,
                      50, 50, 50, 50, 0, 10,
                      50, 50, 50, 50, pi, 10,
                      20, 20, 20, 20, 0, 10,
                      20, 20, 50, 50, 0, 10), nrow = 5, byrow = T))

colnames(tab.start) <- c("Shape", "Scale", "Shape", "Scale", "Mean", "Concentration")
rownames(tab.start) <- c("Fixation", "Saccade", "PSO", "Pursuit", "Event 5")

apa_table(as.data.frame(tab.start),
          col_spanners = list(Velocity = c(2, 3), Acceleration = c(4, 5), "Rel. angle" = c(6, 7)),
          format.args = list(na_string = "-", drop0trailing = T),
          caption = "(ref:tab-starting-values)",
          note = "(ref:tab-starting-values-note)")

```


### Model Comparison

```{r load validation results, include=FALSE}

load(here("validation/Andersson2017_fitted.Rdata"))
load(here("validation/Andersson2017_raw.Rdata"))

```

```{r calculate Schwarz weights, include=FALSE}

# Compute Schwarz weights

schwarz.weights <- function(bic, na.rm = T) {
  
  d.bic <- bic - min(bic, na.rm = na.rm) # eq 2
  
  exp(-0.5 * d.bic)/sum(exp(-0.5 * d.bic), na.rm = na.rm) # eq 4
  
}

A2017.bic <- lapply(A2017.fit, function(stim) {
  out <- lapply(stim, function(subj) {
    out <- lapply(1:length(subj), function(mod) {
      
      if(mod == 1) {
        
        bic <- try(-2*subj[[mod]][["LL"]] + 6*log(subj[[mod]][["N"]]))
        
      } else {
        
        bic <- try(BIC(subj[[mod]]$model))
        
      }
      
      return(ifelse(is.numeric(bic), bic, NA))
    })
    
    return(schwarz.weights(unlist(out)))
  })
  
  df <- as.data.frame(reduce(out, rbind))
  
  names(df) <- paste("model_", 1:length(stim[[1]]), sep = "")
  
  return(df)
})


# Create Schwarz weight plots

bic.plot <- lapply(A2017.bic, function(x) {
  
  data.long <- x %>% 
    mutate(subject = 1:nrow(x)) %>%
    pivot_longer(names(x), names_to = "model", values_to = "weight") %>%
    mutate_at(c("subject", "model"), as.factor)
  
  p <- ggplot(data.long, aes(x = model, y = subject)) + geom_tile(aes(fill = weight)) +
    scale_x_discrete(name = "Number of states", labels = as.character(1:5)) +
    scale_y_discrete(name = "Subject") +
    scale_fill_distiller(name = "Schwarz\nweight", breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1), palette = "Spectral")
  
  return(p)
})

```

To examine whether HMMs are accurately describing eye movements, I applied gazeHMM with one, two, three, four, and five states on two benchmark data sets and compared the Schwarz weights of the HMMs. Schwarz weights are the result of transforming a set of BIC values. They can be interpreted as the probability for a model to have generated the data it was fitted to. For the @Andersson2017 data set, I expected the highest weights for the three-state models in the image condition. For the moving dots and video conditions, I predicted the highest weights for the four-state model. Figure \@ref(fig:plot-schwarz-weights-img) shows the Schwarz weights for different subjects and models in the image condition. For all subjects, the five-state model displays the highest weight, suggesting that it hast most likely generated the data. In the moving dots condition, the five-state model has the highest weights for most subjects, but the one-, three, and four-state models exhibit the highest weights for two subjects each (see Figure \@ref(fig:plot-schwarz-weights-dots)). The video condition has the same pattern as the image condition, as the five-state model consistently has the highest weights (see Figure \@ref(fig:plot-schwarz-weights-vid)). In contrast to my hypothesis, applying different HMMs to the @Andersson2017 data suggests that the five-state model has most likely generated the data. Except for the moving dots condition, there was little variation in the Schwarz weights, indicating large differences in the model likelihoods. The model comparison for the @Ehinger2019 data set yielded similar results (see Appendix).

(ref:plot-schwarz-weights-img) Schwarz weights displayed for each subject and HMMs with different numbers of states. Models were applied to the image condition of the @Andersson2017 data set. Higher weights indicate better model fit.

```{r plot-schwarz-weights-img, fig.cap="(ref:plot-schwarz-weights-img)"}

print(bic.plot[[2]])

```

(ref:plot-schwarz-weights-dots) Schwarz weights displayed for each subject and HMMs with different numbers of states. Models were applied to the moving dots condition of the @Andersson2017 data set. Higher weights indicate better model fit.

```{r plot-schwarz-weights-dots, fig.cap="(ref:plot-schwarz-weights-dots)"}

print(bic.plot[[1]])

```

(ref:plot-schwarz-weights-vid) Schwarz weights displayed for each subject and HMMs with different numbers of states. Models were applied to the video condition of the @Andersson2017 data set. Higher weights indicate better model fit.

```{r plot-schwarz-weights-vid, fig.cap="(ref:plot-schwarz-weights-vid)"}

print(bic.plot[[3]])

```

### Comparison to Other Algorithms

```{r calculate duration RMSD, include=FALSE}

# Calculate event descriptives for human coders

fr <- 500

A2017.events <- lapply(A2017, function(stim) {
  lapply(1:4, function(e) {
    out <- lapply(stim, function(df) {
      
      if(all(is.nan(df$t) || df$t == 0)) {
        
        df$t <- seq(0, length(df$t)-1)/fr
        
      } else {
        
        df$t <- (df$t - df$t[1])/1e6
        
        df <- df[df$t >= 0,]
        
      }
      
      counter_MN <- 1
      counter_RA <- 1
      
      number_MN <- numeric(nrow(df))
      number_RA <- numeric(nrow(df))
      
      number_MN[1] <- 1
      number_RA[1] <- 1
      
      for (i in 2:nrow(df)) {
        if(df$label_MN[i] != df$label_MN[i-1]) counter_MN <- counter_MN + 1
        if(df$label_RA[i] != df$label_RA[i-1]) counter_RA <- counter_RA + 1
        
        number_MN[i] <- counter_MN
        number_RA[i] <- counter_RA
    
      }
      
      dur_MN <- numeric(max(number_MN))
      event_MN <- numeric(max(number_MN))
      
      for (n in unique(number_MN)) {
        if(n > 1) {
          dur_MN[n] <- max(df$t[number_MN == n], na.rm = T) - max(df$t[number_MN == (n-1)], na.rm = T)
        } else {
          dur_MN[n] <- max(df$t[number_MN == n], na.rm = T) - min(df$t[number_MN == n], na.rm = T)
        }
        
        event_MN[n] <- max(df$label_MN[number_MN == n], na.rm = T)
      }
      
      dur_RA <- numeric(max(number_RA))
      event_RA <- numeric(max(number_RA))
      
      for (n in unique(number_RA)) {
        if(n > 1) {
          dur_RA[n] <- max(df$t[number_RA == n], na.rm = T) - max(df$t[number_RA == (n-1)], na.rm = T)
        } else {
          dur_RA[n] <- max(df$t[number_RA == n], na.rm = T) - min(df$t[number_RA == n], na.rm = T)
        }
        
        event_RA[n] <- max(df$label_RA[number_RA == n], na.rm = T)
      }
      
      return(list(dur_MN[event_MN == e], dur_RA[event_RA == e]))
    })
    
    df <- reduce(out, cbind)
    
    dur_MN <- unlist(df[1,])
    dur_RA <- unlist(df[2,])
    
    return(data.frame(MN = c(mean(dur_MN), sd(dur_MN), length(dur_MN)),
                      RA = c(mean(dur_RA), sd(dur_RA), length(dur_RA))))
  })
})


# Calculate RMSD between event distribution descriptives

ref <- list(dot = list(fix = list(CDT = c(60, 127, 165),
                                  EM = c(NA, NA, NA),
                                  IDT = c(323, 146, 8),
                                  IKF = c(217, 184, 72),
                                  IMST = c(268, 140, 12),
                                  IHMM = c(214, 286, 67),
                                  IVT = c(203, 282, 71),
                                  NH = c(380, 333, 30),
                                  BIT = c(189, 113, 67),
                                  LNS = c(NA, NA, NA)),
                       sac = list(CDT = c(NA, NA, NA),
                                  EM = c(17, 14, 93),
                                  IDT = c(32, 14, 10),
                                  IKF = c(60, 26, 29),
                                  IMST = c(13, 5, 18),
                                  IHMM = c(41, 17, 27),
                                  IVT = c(36, 14, 28),
                                  NH = c(43, 16, 42),
                                  BIT = c(NA, NA, NA),
                                  LNS = c(26, 11, 53)),
                       pso = list(NH = c(24, 12, 17),
                                  LNS = c(20, 9, 31))),
            img = list(fix = list(CDT = c(397, 559, 251),
                                  EM = c(NA, NA, NA),
                                  IDT = c(399, 328, 242),
                                  IKF = c(174, 239, 513),
                                  IMST = c(304, 293, 333),
                                  IHMM = c(133, 216, 701),
                                  IVT = c(114, 204, 827),
                                  NH = c(258, 299, 292),
                                  BIT = c(209, 136, 423),
                                  LNS = c(NA, NA, NA)),
                       sac = list(CDT = c(NA, NA, NA),
                                  EM = c(25, 22, 787),
                                  IDT = c(25, 15, 258),
                                  IKF = c(62, 37, 353),
                                  IMST = c(17, 10, 335),
                                  IHMM = c(48, 26, 368),
                                  IVT = c(41, 22, 373),
                                  NH = c(50, 20, 344),
                                  BIT = c(NA, NA, NA),
                                  LNS = c(29, 12, 390)),
                       pso = list(NH = c(28, 13, 237),
                                  LNS = c(25, 9, 319))),
            vid = list(fix = list(CDT = c(213, 297, 211),
                                  EM = c(NA, NA, NA),
                                  IDT = c(554, 454, 48),
                                  IKF = c(258, 296, 169),
                                  IMST = c(526, 825, 71),
                                  IHMM = c(234, 319, 194),
                                  IVT = c(202, 306, 227),
                                  NH = c(429, 336, 83),
                                  BIT = c(248, 215, 170),
                                  LNS = c(NA, NA, NA)),
                       sac = list(CDT = c(NA, NA, NA),
                                  EM = c(20, 16, 252),
                                  IDT = c(24, 53, 41),
                                  IKF = c(55, 20, 107),
                                  IMST = c(18, 10, 76),
                                  IHMM = c(42, 18, 109),
                                  IVT = c(36, 16, 112),
                                  NH = c(44, 18, 104),
                                  BIT = c(NA, NA, NA),
                                  LNS = c(28, 12, 122)),
                       pso = list(NH = c(28, 13, 78),
                                  LNS = c(24, 10, 87))))


A2017.rmsd <- lapply(2:4, function(k) {
  lapply(1:length(A2017.fit), function(x) { 
    out <- lapply(1:k, function(y) {
      out <- lapply(A2017.fit[[x]], function(z) {
        
        if(class(z[[k]]) == "gazeHMM") z[[k]]$events[[y]]
        
      })
      
      df <- try(reduce(out, rbind))
      
      alg <- try(c(mean(df$dur, na.rm = T), sd(df$dur, na.rm = T), nrow(df)))
      
      if(y == 4) {
        M <- try(cbind(A2017.events[[x]][[y]], alg))
      } else {
        M <- try(cbind(A2017.events[[x]][[y]], alg, as.data.frame(ref[[x]][[y]])))
        M[1:2,4:ncol(M)] <- M[1:2,4:ncol(M)]/1e3
      }
      
      M.norm <- try(apply(M, 1, function(x) {(x - min(x, na.rm = T))/(max(x, na.rm = T) - min(x, na.rm = T))}))
      
      if(y == 4) {
        rmsd <- try(sum(sqrt((M.norm[3,] - colSums(M.norm[1:2,]/2))^2)))
      } else {
        rmsd <- try(apply(M.norm[3:nrow(M.norm),], 1, function(r) {sum(sqrt((r - colSums(M.norm[1:2,]/2))^2))}))
      }
      
      coder <- try(sum(sqrt((M.norm[1,] - M.norm[2,])^2)))
      
      rmsd <- c(coder, coder, rmsd)
      
      return(rbind(M, rmsd))
    })
  })
})


# Create tables for RMSDs

rmsd.table <- lapply(1:length(A2017.rmsd), function(x) {
  out <- lapply(1:length(A2017.rmsd[[x]]), function(y) {
    out <- lapply(1:length(A2017.rmsd[[x]][[y]]), function(z) {
      
      tabmat <- t(apply(A2017.rmsd[[x]][[y]][[z]], 2, function(d) {as.character(round(d, 3))}))
      
      # tabmat[3,] <- paste("**", tabmat[3,], "**", sep = "")
      
      colnames(tabmat) <- c("Mean", "SD", "Events", "RMSD")
      rownames(tabmat)[1:3] <- c("coderMN", "coderRA", "gazeHMM")
      
      return(cbind(z, rownames(tabmat), tabmat))
    })
    
    cbind(y, reduce(out, rbind))
  })
  
  df <- as.data.frame(reduce(out, rbind), stringsAsFactors = F) %>%
    mutate(Condition = factor(y, labels = c("moving dots", "image", "video"))) 
  
  lapply(1:(x+1), function(x) {
    
    df <- df %>% dplyr::filter(z == x) %>%
      dplyr::select(-c("z", "y")) %>%
      rename(Algorithm = V3) %>%
      pivot_wider(names_from = "Condition", names_glue = "{Condition}_{.value}", names_sort = T, values_from = c("Mean", "SD", "Events", "RMSD")) 
    
    df %>% dplyr::select(c("Algorithm", "image_Mean", "image_SD", "image_Events", "image_RMSD",
                           "moving dots_Mean", "moving dots_SD", "moving dots_Events", "moving dots_RMSD",
                           "video_Mean", "video_SD", "video_Events", "video_RMSD"))
  })
})

```

```{r calculate Cohen s kappa and confusion matrices, include= FALSE}

# Compute Cohen's kappa and confusion matrices

ref.acc <- matrix(c(0.92, 0.81, 0.83, 0.95, 0.91, 0.94, 0.88, 0.82, 0.83, 0.00, 0.00, 0.00,
                    0.92, 0.84, 0.82, 0.95, 0.91, 0.94, 0.88, 0.80, 0.81, 0.00, 0.00, 0.00,
                    0.38, 0.06, 0.11, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.00, 0.00, 0.00, 0.64, 0.66, 0.67, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.36, 0.00, 0.03, 0.45, 0.26, 0.38, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.63, 0.03, 0.14, 0.58, 0.46, 0.59, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.38, 0.00, 0.03, 0.54, 0.30, 0.52, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.67, 0.03, 0.13, 0.69, 0.60, 0.71, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.67, 0.03, 0.13, 0.75, 0.63, 0.76, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.52, 0.00, 0.01, 0.67, 0.60, 0.68, 0.24, 0.20, 0.25, 0.00, 0.00, 0.00,
                    0.67, 0.03, 0.14, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
                    0.00, 0.00, 0.00, 0.81, 0.75, 0.81, 0.64, 0.59, 0.63, 0.00, 0.00, 0.00), ncol = 12, byrow = T)

A2017.acc <- lapply(2:4, function(k) {
  lapply(1:length(A2017.fit), function(x) { 
    out <- lapply(1:length(A2017.fit[[x]]), function(y) {
      
      if(class(A2017.fit[[x]][[y]][[as.character(k)]]) == "gazeHMM") {
        cod.MN <- as.data.frame(cbind(A2017.fit[[x]][[y]][[as.character(k)]]$samples$label, A2017[[x]][[y]]$label_MN))
        cod.RA <- as.data.frame(cbind(A2017.fit[[x]][[y]][[as.character(k)]]$samples$label, A2017[[x]][[y]]$label_RA))
        
        return(rbind(cod.MN, cod.RA))
      }
    })
    
    df <- reduce(out, rbind)
    
    df[df[,1] == 0,1] <- 5
    
    events <- lapply(1:k, function(e) {
      
      alg <- df[,1] == e
      cod <- df[,2] == e
      
      mat <- matrix(c(sum(alg & cod, na.rm = T), sum(alg & !cod, na.rm = T), 
                      sum(!alg & cod, na.rm = T), sum(!alg & !cod, na.rm = T)), 2, 2)
      
      over <- mat[2,1]/sum(mat[,1])
      under <- mat[1,2]/sum(mat[,2])
      
      return(list(kappa = cohen.kappa(mat)$kappa, 
                  over = over,
                  under = under))
    })
    
    ratio <- mean(df[,1] != df[,2], na.rm = T)
    
    conmat <- table(df[,1], df[,2])
    
    return(list(events = events, ratio =  ratio, conmat = conmat))
  })
})


# Create tables for Cohen's kappa and confusion matrices

kappa.table <- lapply(A2017.acc, function(x) {
  out <- lapply(x, function(y){
    out <- lapply(y$events, function(z){
      return(round(z$kappa, 3))
    })
    
    return(reduce(out, cbind))
  })
  
  tabmat <- reduce(out, rbind)
  
  tabmat <- rbind(tabmat[2,], tabmat[1,], tabmat[3,])
  
  return(as.vector(tabmat))
})

conf.table <- lapply(A2017.acc, function(x) {
  out <- lapply(x, function(y){
    
    tabmat <- apply(y$conmat, 2, as.character)
    
    # diag(tabmat)[1:(nrow(tabmat)-1)] <- paste("**", diag(tabmat)[1:(nrow(tabmat)-1)], "**", sep = "")
    
    # tabmat[nrow(tabmat), 5] <- paste("**", tabmat[nrow(tabmat), 5], "**", sep = "")

    colnames(tabmat) <- c("Fixations", "Saccades", "PSOs", "Pursuits", "Blinks", "Other")
    rownames(tabmat) <- c("Fixations", "Saccades", "PSOs", "Pursuits", "Blinks", "Other")[1:nrow(tabmat)]
    rownames(tabmat)[nrow(tabmat)] <- "Blinks"

    return(as.data.frame(tabmat))
  })
})


# Create figure for disagreement ratio

ref.disag <- list(c(7, 7, A2017.acc[[3]][[2]]$ratio*100, A2017.acc[[2]][[2]]$ratio*100, 23, 92, 20, 24, 20, 20, 19, 32, 31, 84),
                  c(11, 11, A2017.acc[[3]][[1]]$ratio*100, A2017.acc[[2]][[1]]$ratio*100, 89, 96, 86, 85, 86, 84, 84, 93, 89, 93),
                  c(19, 19, A2017.acc[[3]][[3]]$ratio*100, A2017.acc[[2]][[3]]$ratio*100, 64, 95, 61, 62, 61, 59, 59, 70, 67, 92))

disag.df <- data.frame(Image = ref.disag[[1]], Dots = ref.disag[[2]], Video = ref.disag[[3]],
                       Algorithm = c("coderMN", "coderRA", "gazeHMM-4", "gazeHMM-3", "CDT", "EM", "IDT", "IKF", "IMST", "IHMM", "IVT", "NH", "BIT", "LNS"),
                       stringsAsFactors = F)

disag.df$Algorithm <- factor(disag.df$Algorithm, levels = unique(disag.df$Algorithm))

disag.df <- disag.df %>% pivot_longer(c("Image", "Dots", "Video"), names_to = "Condition", values_to = "Ratio")

disag.plot <- ggplot(disag.df, aes(x = Algorithm, y = Ratio, fill = Condition)) + 
  geom_col(position = "dodge") + 
  scale_y_continuous(name = "Disagreement (in %)", limits = c(0, 100), breaks = c(0, 0.25, 0.5, 0.75, 1)*100) +
  scale_x_discrete(name = "") + coord_flip()

```

#### Event Durations
The hypothesis that HMMs improve the classification performance of eye movement events was investigated by comparing gazeHMM against other algorithms. Therefore, I applied gazeHMM with four events to the @Andersson2017 data set. Therefore, I calculated the RMSD [^3] of event durations  as described in the original article by Andersson et al. for all algorithms included in the study plus gazeHMM: First, the mean and standard deviation of event durations as well as the number of events were normalized to [0,1] for each coder and algorithm. Second, the sum of the root square deviation between each algorithm and the average of the two human coders is computed. This metric can only be relatively interpreted [@Andersson2017].  
Table \@ref(tab:tab-rmsd-4-fix) shows that, in all three conditions, gazeHMM has a higher RMSD than all the the other algorithms for classified fixations. The high RMSD values were mostly due to a large amount of very short fixations.  
For saccades, gazeHMM has a relatively low RMSD of the algorithms in the image and video condition and a relatively high RMSD in the moving dots condition (see Table \@ref(tab:tab-rmsd-4-sac)). Here, gazeHMM overestimated the duration of saccades, as indicated by high mean and SD durations.  
For PSOs, gazeHMM had the highest RMSD in the image and video condition (see Table \@ref(tab:tab-rmsd-4-pso)). In the moving dots condition, its RMSD was lower than for NH [@Nystrom2010] but higher than for LNS [@Larsson2013]. Here, gazeHMM underestimated the number of PSOs and their duration compared to the human coders.  
No other algorithm in the study was designed to classify smooth pursuits, but gazeHMM classified a large number of short smooth pursuits, causing a substantially higher RMSD than the human coders (see Figure \@ref(tab:tab-rmsd-4-sp)).  
In sum, gazeHMM did not outperform all other algorithms regarding the RMSD of event durations compared to human coders. The duration of fixations and smooth pursuits was largely underestimated and the number of these two events largely overestimated. For saccades and PSOs, gazeHMM estimated relatively accurate durations and event numbers, but didn't reach the best algorithms.

(ref:tab-rmsd-4-fix) Mean and standard deviations of fixation durations, number of fixations, and RMSD between fixation durations classified by algorithms and human coders
(ref:tab-rmsd-4-fix-note) Durations are displayed in seconds. gazeHMM classified four events. RMSD = root mean square deviation. Table adapted from @Andersson2017.

```{r tab-rmsd-4-fix}

apa_table(rmsd.table[[3]][[1]],
          col.names = c("Algorithm", rep(c("Mean", "SD", "Events", "RMSD"), 3)),
          col_spanners = list("Image" = c(2, 5), "Moving dots" = c(6, 9), "Video" = c(10, 13)),
          font_size = "tiny",
          format.args = list(na_string = "-", drop0trailing = T),
          caption = "(ref:tab-rmsd-4-fix)",
          note = "(ref:tab-rmsd-4-fix-note)")

```

(ref:tab-rmsd-4-sac) Mean and standard deviations of saccade durations, number of saccades, and RMSD between saccade durations classified by algorithms and human coders
(ref:tab-rmsd-4-sac-note) Durations are displayed in seconds. gazeHMM classified four events. RMSD = root mean square deviation. Table adapted from @Andersson2017.

```{r tab-rmsd-4-sac}

apa_table(rmsd.table[[3]][[2]],
          col.names = c("Algorithm", rep(c("Mean", "SD", "Events", "RMSD"), 3)),
          col_spanners = list("Image" = c(2, 5), "Moving dots" = c(6, 9), "Video" = c(10, 13)),
          font_size = "tiny",
          format.args = list(na_string = "-", drop0trailing = T),
          caption = "(ref:tab-rmsd-4-sac)",
          note = "(ref:tab-rmsd-4-sac-note)")

```

(ref:tab-rmsd-4-pso) Mean and standard deviations of PSO durations, number of PSOs, and RMSD between PSO durations classified by algorithms and human coders
(ref:tab-rmsd-4-pso-note) Durations are displayed in seconds. gazeHMM classified four events. RMSD = root mean square deviation. Table adapted from @Andersson2017.

```{r tab-rmsd-4-pso}

apa_table(rmsd.table[[3]][[3]],
          col.names = c("Algorithm", rep(c("Mean", "SD", "Events", "RMSD"), 3)),
          col_spanners = list("Image" = c(2, 5), "Moving dots" = c(6, 9), "Video" = c(10, 13)),
          font_size = "tiny",
          format.args = list(na_string = "-", drop0trailing = T),
          caption = "(ref:tab-rmsd-4-pso)",
          note = "(ref:tab-rmsd-4-pso-note)")

```

(ref:tab-rmsd-4-sp) Mean and standard deviations of smooth pursuit durations, number of smooth pursuits, and RMSD between smooth pursuit durations classified by algorithms and human coders
(ref:tab-rmsd-4-sp-note) Durations are displayed in seconds. gazeHMM classified four events. RMSD = root mean square deviation. Table adapted from @Andersson2017.

```{r tab-rmsd-4-sp}

apa_table(rmsd.table[[3]][[4]],
          col.names = c("Algorithm", rep(c("Mean", "SD", "Events", "RMSD"), 3)),
          col_spanners = list("Image" = c(2, 5), "Moving dots" = c(6, 9), "Video" = c(10, 13)),
          font_size = "tiny",
          format.args = list(na_string = "-", drop0trailing = T),
          caption = "(ref:tab-rmsd-4-sp)",
          note = "(ref:tab-rmsd-4-sp-note)")

```

[^3]: In my proposal, I declared to compute the RMSE instead of RMSD. However, since I conducted an in sample comparison, the term deviation is more appropriate. Andersson et al. (2017) also referred to it as RMSD.

#### Sample-to-sample Agreement
Moreover, I compared gazeHMM to the other algorithms by using Cohen's kappa as a measure of sample-to-sample agreement between algorithms and human coders (see Table \@ref(tab:tab-kappa-4)). Cohen's kappa indicates the agreement between to classifiers accounting for the agreement due to chance. Absolute values were interpreted according to @Landis1977.  
For fixations, absolute kappa values in all three conditions indicated a slight to fair agreement between gazeHMM and human coders. Compared to the other algorithms, the agreement of gazeHMM was the lowest in the image condition but the highest in the moving dots and video condition.  
For saccades, gazeHMM showed kappa values that correspond to a moderate to substantial agreement were relatively high compared to the other algorithms. However, gazeHMM never reached the highest agreement.  
For PSOs, absolute kappa values showed slight to fair agreement agreement to human coders. It was relatively low in the moving dots condition and mediocre in the image and video conditions compared to NH and LNS.  
The agreement for smooth puruits was moderate in the moving dots condition but slight in the image and video conditions. No other algorithm in the study was designed to detect smooth pursuits.  
In sum, gazeHMM revealed a relatively high sample-to-sample agreement to human coders for saccades. For PSOs and smooth pursuits, I found mediocre agreement. The performance for fixations was absolutely and relatively low.

(ref:tab-kappa-4) Cohen's kappa between human coders and algorithms for different conditions and events
(ref:tab-kappa-4-note) Negative values were set to zero. gazeHMM classified four events. Table adapted from @Andersson2017.

```{r tab-kappa-4}

tab.kappa.4 <- cbind(c("coderMN", "coderRA", "gazeHMM", "CDT", "EM", "IDT", "IKF", "IMST", "IHMM", "IVT", "NH", "BIT", "LNS"),
                     as.data.frame(rbind(ref.acc[1:2,], kappa.table[[3]], ref.acc[3:nrow(ref.acc),]))) 

apa_table(tab.kappa.4,
          col.names = c("Algorithm", rep(c("Image", "Dots", "Video"), 4)),
          col_spanners = list("Fixations" = c(2, 4), "Saccades" = c(5, 7), "PSOs" = c(8, 10), "Smooth pursuit" = c(11, 13)),
          font_size = "tiny",
          caption = "(ref:tab-kappa-4)",
          note = "(ref:tab-kappa-4-note)")

```

#### Disagreement and Confusion
At last, I computed the overall disagreement [^4] as the percentage of all samples taken together that were classified differently by gazeHMM than the human coders. Figure \@ref(fig:plot-disag) shows that in the image condition, gazeHMM with four events had a higher overall disagreement than all but two of the other algorithms. In the moving dots and video conditions, the disagreement was considerably lower than for all the other algorithms. Notably, gazeHMM's disagreement was similar across conditions (around 45%). In summary, gazeHMM had a lower overall disagreement than all other algorithms in the moving dots and video conditions but higher disagreement in the image condition.

[^4]: Even though I proposed to compute the *disagreement ratio* and @Andersson2017 also used that term, the comparison technically involves percentages and not ratios. Thus, I decdided to use only the term *disagreement* instead.

(ref:plot-disag) Disagreement between algorithms and human coders for different conditions (in %). gazeHMM-3 classified three and gazeHMM-4 classified four events. Figure adapted from @Andersson2017.

```{r plot-disag, fig.cap="(ref:plot-disag)"}

print(disag.plot)

```

(ref:tab-conf-4) Confusion matrix between gazeHMM (rows) and human coders (columns) for different events and conditions
(ref:tab-conf-4-note) gazeHMM classified four events and blinks.

```{r tab-conf-4}

tab.conf.4 <- cbind(Event = rep(c("Fixations", "Saccades", "PSOs", "Pursuits", "Blinks"), 3), reduce(conf.table[[3]], rbind)) %>%
  mutate(Condition = rep(c("Moving dots", "Image", "Video"), each = 5)) %>%
  arrange(Condition) %>%
  dplyr::select(-Condition)

apa_table(tab.conf.4,
          stub_indents = list("Image" = c(1:5), "Moving dots" = c(6:10), "Video" = c(11:15)),
          midrules = c(6, 12),
          caption = "(ref:tab-conf-4)",
          note = "(ref:tab-conf-4-note)")

```

Contrary to my second hypothesis, applying gazeHMM to a benchmark data set revealed that it did not outperform all other algorithms in terms of RMSD and sample-to-sample agreement. The two criteria rather indicated a mediocre performance of gazeHMM. However, the overall disagreement was lower for gazeHMM than for all other algorithms in the dynamic conditions but the highest in the static image condition.  
Looking at the confusion matrix in Table \@ref(tab:tab-conf-4), it can be seen that gazeHMM confused fixations and smooth pursuit to a large extend. In the image condition, it overclassified smooth pursuit events, while they were underclassified in the dynamic conditions.

### gazeHMM With Three States
Even though it was not confirmed by the model comparison, applying gazeHMM with three states to static data seems theoretically more appropriate. Including only three states could prevent gazeHMM from overclassifying smooth pursuits in the image data and yield better validation results. Therefore, I decided to apply gazeHMM with three states to the image dat and repeat the comparison to other algorithms exploratorily.  
Table \@ref(tab:tab-rmsd-3) shows the RMSD between gazeHMM and human coders only for the image condition. For fixations, gazeHMM shows a comparably low RMSD but it was relatively high for saccades and PSOs. 
The sample-to-sample agreement between gazeHMM with three states and the human coders measured by Cohen's kappa is displayed in Table \@ref(tab:tab-kappa-3) (only for the image condition). For fixations, the absolute kappa indicated substantial agreement and was relatively high compared to the other algorithms. The absolute kappa for saccades corresponded to moderate agreement. Compared to the other algorithms, it was rather low. For PSOs, the absolute agreement was fair, but relatively low compared to the other algorithms.  
Figure \@ref(fig:plot-disag) illustrates the overall disagreement between gazeHMM with three events and the human coders compared to the other algorithms. In all three conditions, the disagreement was slightly lower for gazeHMM than for all the other algorithms. Compared to gazeHMM with four states, the RMSD decreased while the sample-to-sample agreement increased for fixations. For saccades and PSOs, the opposite pattern was found. The overall disagreement substantially decreased. Overall, applying gazeHMM with three states to static data seems more appropriate, since the increase in fixation classification outweighs the decrease in classification of saccades and PSOs. There was even some support for my second hypothesis since gazeHMM had lower overall disagreement to human coders than all other algorithms.

(ref:tab-rmsd-3) Mean and standard deviation of event durations, number of events, and RMSD between event durations classified by algorithms and human coders for the image condition
(ref:tab-rmsd-3-note) Durations are displayed in seconds. gazeHMM classified three events. RMSD = root mean square deviation. Table adapted from @Andersson2017.

```{r tab-rmsd-3}

tab.rmsd.3 <- lapply(A2017.rmsd[[2]][[2]], function(x) {
  
  df <- as.data.frame(t(as.matrix(x)))
  
  rownames(df)[3] <- "gazeHMM"
  
  out <- cbind(algorithm = rownames(df), df)
  
  return(out)
}) %>% reduce(left_join, by = "algorithm")

apa_table(tab.rmsd.3,
          col.names = c("Algorithm", rep(c("Mean", "SD", "Events", "RMSD"), 3)),
          col_spanners = list("Fixations" = c(2, 5), "Saccades" = c(6, 9), "PSOs" = c(10, 13)),
          font_size = "tiny",
          format.args = list(na_string = "-", drop0trailing = T),
          caption = "(ref:tab-rmsd-3)",
          note = "(ref:tab-rmsd-3-note)")

```

(ref:tab-kappa-3) Cohen's kappa between human coders and algorithms for different events in the image condition
(ref:tab-kappa-3-note) Negative values were set to zero. gazeHMM-3 classified three and gazeHMM-4 classified four events. Table adapted from @Andersson2017.

```{r tab-kappa-3}

tab.kappa.3 <- cbind(c("coderMN", "coderRA", "gazeHMM-4", "gazeHMM-3", "CDT", "EM", "IDT", "IKF", "IMST", "IHMM", "IVT", "NH", "BIT", "LNS"),
                     as.data.frame(rbind(ref.acc[1:2, 1:9], kappa.table[[3]][1:9], kappa.table[[2]], ref.acc[3:nrow(ref.acc), 1:9]))) %>%
  dplyr::select(c(1, seq(2, 10, 3)))

apa_table(tab.kappa.3,
          col.names = c("Algorithm", "Fixations", "Saccades", "PSOs"),
          caption = "(ref:tab-kappa-3)",
          note = "(ref:tab-kappa-3-note)")

```

# Discussion
In this report, I presented gazeHMM, a novel algorithm for classifying gaze data into eye movement events. The algorithm models velocity, acceleration, and sample-to-sample angle signals with gamma distributions and a mixture of von-Mises and a uniform distribution. An HMM classifies the gaze samples into fixations, saccades, and optionally PSOs, and/or smooth pursuits. A simulation study revealed that the generative model of gazeHMM recovered parameters and hidden state sequence well with a few exceptions. Adding smooth pursuits to the model and noise to the generated data were the most critical factors for decreasing recovery. In contrast, higher sample sizes yielded a better parameter recovery. The variation in starting values did not affect the recovery but the amount of missing data decreased the recovery of hidden states. I applied gazeHMM with different numbers of states to benchmark data and compared the model fit, showing that a five-state HMM had consistently most likely generated the data. This result speaks against my first hypothesis that HMMs are useful generative models for eye movements. When comparing gazeHMM with four events against other algorithms and human coders, it did not show the best performance for the duration and number of classified events nor the sample-to-sample agreement across all conditions. However, it had a lower overall disagreement for dynamic data but higher disagreement for static data. I argued that four states might not be appropriate for static data and additionally applied gazeHMM with three states to them. That led to substantially better classifications for fixations, but slightly worse performance for saccades and PSOs. With three states, gazeHMM had a lower overall disagreement than all other algorithms. I treat this pattern as moderate evidence for my second hypothesis that HMMs improve the classification of eye movements. Taken together, I only found some evidence for the one part of my research question: HMMs improve classifying gaze data but not describing them.  



\newpage

# Technical Appendix
# References

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id = "refs"></div>
\endgroup